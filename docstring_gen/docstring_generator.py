# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Docstring_Generator.ipynb.

# %% auto 0
__all__ = ['DOCSTRING_RETRY_ATTEMPTS', 'PROMPT_TEMPLATE', 'DEFAULT_PROMPT', 'AUTO_GEN_PERFIX', 'AUTO_GEN_BODY', 'AUTO_GEN_SUFFIX',
           'AUTO_GEN_TXT', 'add_docstring_to_source']

# %% ../nbs/Docstring_Generator.ipynb 2
import time
import random
import ast
import textwrap
import os
import re
from typing import *
from pathlib import Path

import nbformat
import openai
import typer

# %% ../nbs/Docstring_Generator.ipynb 5
def _get_end_line_for_class_or_func(source: str, lineno: int) -> int:

    lines = source.split("\n")[lineno - 1 :]
    first_indent = len(lines[0]) - len(lines[0].lstrip())
    end_line_in_source = 0

    for i, line in enumerate(lines[1:]):
        if len(line) - len(line.lstrip()) == first_indent and line.strip() != "":
            end_line_in_source = i
            break

    ret_val = (
        len(source.split("\n"))
        if end_line_in_source == 0
        else end_line_in_source + lineno
    )
    return ret_val - 1

# %% ../nbs/Docstring_Generator.ipynb 8
def _get_code_from_source(source: str, start_line_no: int, end_line_no: int) -> str:
    source_lines = source.split("\n")
    extracted_lines = source_lines[start_line_no - 1 : end_line_no]
    return "\n".join(extracted_lines)

# %% ../nbs/Docstring_Generator.ipynb 10
# Reference: https://github.com/openai/openai-cookbook/blob/main/examples/How_to_handle_rate_limits.ipynb


def _retry_with_exponential_backoff(
    initial_delay: float = 1,
    exponential_base: float = 2,
    jitter: bool = True,
    max_retries: int = 20,
    max_wait: float = 60,
    errors: tuple = (
        openai.error.RateLimitError,
        openai.error.ServiceUnavailableError,
        openai.error.APIError,
    ),
) -> Callable:
    """Retry a function with exponential backoff."""

    def decorator(func):
        def wrapper(*args, **kwargs):
            num_retries = 0
            delay = initial_delay

            while True:
                try:
                    return func(*args, **kwargs)

                except errors as e:
                    num_retries += 1
                    if num_retries > max_retries:
                        raise Exception(
                            f"Maximum number of retries ({max_retries}) exceeded."
                        )
                    delay = min(
                        delay
                        * exponential_base
                        * (1 + jitter * random.random()),  # nosec
                        max_wait,
                    )
                    typer.secho(
                        f"Note: OpenAI's API rate limit reached. Command will automatically retry in {int(delay)} seconds. For more information visit: https://help.openai.com/en/articles/5955598-is-api-usage-subject-to-any-rate-limits",
                        fg=typer.colors.BLUE,
                    )
                    time.sleep(delay)

                except Exception as e:
                    raise e

        return wrapper

    return decorator


@_retry_with_exponential_backoff()
def _completions_with_backoff(**kwargs):
    """This function takes in a dictionary of keyword arguments and returns a completion object.

    Args:
        **kwargs: A dictionary of keyword arguments to be passed to the openai.Completion.create() function

    Returns:
        A completion object

    Raises:
        N/A


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    return openai.Completion.create(**kwargs)

# %% ../nbs/Docstring_Generator.ipynb 12
def _get_best_docstring(docstrings: List[str]) -> Optional[str]:
    """_get_best_docstring(docstrings: List[str]) -> Optional[str]

        Returns the best docstring from a list of docstrings.

        Args:
            docstrings: A list of docstrings.

        Returns:
            The best docstring.

        Raises:
            ValueError: If the list of docstrings is empty.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    docstrings = [d for d in docstrings if "Args:" in d]
    docstrings = [d for d in docstrings if "~~~~" not in d]
    return docstrings[0] if len(docstrings) > 0 else None

# %% ../nbs/Docstring_Generator.ipynb 16
DOCSTRING_RETRY_ATTEMPTS = 5

PROMPT_TEMPLATE = '''
# Python 3.7

{source}

{prompt}
"""
'''

# Having multi-line prompts works the best with the codex model
# Note: The prompt must start with the # symbol
DEFAULT_PROMPT = """
# An elaborate, high quality docstring for the above function adhering to the Google python docstring format:
# Any deviation from the Google python docstring format will not be accepted
# Include one line description, args, returns and raises
"""


def _get_response(**kwargs: Union[int, float, Optional[str], List[str]]) -> Any:
    try:
        response = _completions_with_backoff(**kwargs)
    except openai.error.AuthenticationError as e:
        raise openai.error.AuthenticationError(
            "No API key provided. Please set the API key in the environment variable OPENAI_API_KEY=<API-KEY>. You can generate API keys in the OpenAI web interface. See https://onboard.openai.com for details."
        )
    return response.choices


def _generate_docstring_using_codex(
    source: str, **kwargs: Union[int, float, Optional[str], List[str]]
) -> str:
    prompt: str = DEFAULT_PROMPT if kwargs["prompt"] is None else kwargs["prompt"]  # type: ignore
    prompt = f"# {prompt}" if not prompt.startswith("#") else prompt
    kwargs["prompt"] = PROMPT_TEMPLATE.format(source=source, prompt=prompt)

    for i in range(DOCSTRING_RETRY_ATTEMPTS):
        res = _get_response(**kwargs)
        ret_val = _get_best_docstring([d.text for d in res])

        if ret_val is not None:
            return ret_val

    return """!!! note
    
    Failed to generate docs"""

# %% ../nbs/Docstring_Generator.ipynb 19
AUTO_GEN_PERFIX = """!!! note

"""
AUTO_GEN_BODY = "The above docstring is autogenerated by docstring-gen library"
AUTO_GEN_SUFFIX = "(https://github.com/airtai/docstring-gen)"
AUTO_GEN_TXT = AUTO_GEN_PERFIX + AUTO_GEN_BODY + " " + AUTO_GEN_SUFFIX


def _add_auto_gen_txt(docstring: str, indent: int) -> str:
    lines = AUTO_GEN_TXT.split("\n")
    auto_gen_txt = (
        textwrap.indent(lines[0], " " * (indent))
        + "\n"
        + textwrap.indent("\n".join(lines[1:]), " " * (indent + 4))
    )

    docstring = docstring + "\n" + auto_gen_txt + "\n"
    return docstring

# %% ../nbs/Docstring_Generator.ipynb 21
def _fix_docstring_indentation(
    docstring: str, col_offset: int, include_auto_gen_txt: bool
) -> str:
    indent = col_offset + 4
    lines = docstring.split("\n")
    matches = ["Args:", "Returns:", "Raises:"]
    ret_val = (
        textwrap.dedent(lines[0])
        + "\n"
        + "\n".join(
            textwrap.indent(textwrap.dedent(l), " " * indent)
            if any(x in l for x in matches)
            else textwrap.indent(textwrap.dedent(l), " " * (indent + 4))
            for l in lines[1:]
        )
    )

    ret_val = (
        ret_val if not include_auto_gen_txt else _add_auto_gen_txt(ret_val, indent)
    )

    return ret_val

# %% ../nbs/Docstring_Generator.ipynb 24
def _inject_docstring_to_source(
    source: str,
    docstring: str,
    node: Union[ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef],
    line_offset: int,
) -> str:
    lineno = (node.body[0].lineno - 1) + line_offset
    indent = node.col_offset + 4
    lines = source.split("\n")
    lines.insert(
        lineno,
        f'{" " * indent}"""{docstring}{" " * indent}"""',
    )
    return "\n".join(lines)

# %% ../nbs/Docstring_Generator.ipynb 26
def _add_docstring(
    source: str,
    node: Union[ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef],
    line_offset: int,
    include_auto_gen_txt: bool,
    **kwargs: Union[int, float, Optional[str], List[str]],
) -> Tuple[str, int]:

    line_no = node.lineno + line_offset
    end_line_no = _get_end_line_for_class_or_func(source, line_no)
    code = _get_code_from_source(source, line_no, end_line_no)

    docstring = _generate_docstring_using_codex(code, **kwargs)
    docstring = _fix_docstring_indentation(
        docstring, node.col_offset, include_auto_gen_txt
    )
    source = _inject_docstring_to_source(source, docstring, node, line_offset)
    line_offset += len(docstring.split("\n"))

    return source, line_offset

# %% ../nbs/Docstring_Generator.ipynb 28
def _remove_auto_generated_docstring(source: str) -> str:
    return re.sub(
        f'"""((?!""").)*?({AUTO_GEN_BODY}).*?"""', "", source, flags=re.DOTALL
    )

# %% ../nbs/Docstring_Generator.ipynb 30
def _check_and_add_docstrings_to_source(
    source: str,
    include_auto_gen_txt: bool,
    recreate_auto_gen_docs: bool,
    **kwargs: Union[int, float, Optional[str], List[str]]
) -> str:

    if recreate_auto_gen_docs:
        source = _remove_auto_generated_docstring(source)

    tree = ast.parse(source)
    line_offset = 0

    def _add_docstrings_recursively(node):
        nonlocal source, line_offset
        if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
            if ast.get_docstring(node) is None:
                source, line_offset = _add_docstring(
                    source, node, line_offset, include_auto_gen_txt, **kwargs
                )
                if isinstance(node, ast.ClassDef):
                    for n in node.body:
                        _add_docstrings_recursively(n)

    for node in tree.body:
        _add_docstrings_recursively(node)

    return source

# %% ../nbs/Docstring_Generator.ipynb 32
def _get_files(nb_path: Path) -> List[Path]:
    exts = [".ipynb", ".py"]
    files = [
        f
        for f in nb_path.rglob("*")
        if f.suffix in exts
        and not any(p.startswith(".") for p in f.parts)
        and not f.name.startswith("_")
    ]

    if len(files) == 0:
        raise ValueError(
            f"The directory {nb_path.resolve()} does not contain any Python files or notebooks"
        )

    return files

# %% ../nbs/Docstring_Generator.ipynb 35
def _add_docstring_to_nb(
    file: Path,
    version: int,
    include_auto_gen_txt: bool,
    recreate_auto_gen_docs: bool,
    **kwargs: Union[int, float, Optional[str], List[str]]
) -> None:
    _f = nbformat.read(file, as_version=version)
    for cell in _f.cells:
        if cell.cell_type == "code":
            cell["source"] = _check_and_add_docstrings_to_source(
                cell["source"], include_auto_gen_txt, recreate_auto_gen_docs, **kwargs
            )
    nbformat.write(_f, file)


def _add_docstring_to_py(
    file: Path,
    include_auto_gen_txt: bool,
    recreate_auto_gen_docs: bool,
    **kwargs: Union[int, float, Optional[str], List[str]]
) -> None:
    with file.open("r") as f:
        source = f.read()
    source = _check_and_add_docstrings_to_source(
        source, include_auto_gen_txt, recreate_auto_gen_docs, **kwargs
    )
    with file.open("w") as f:
        f.write(source)


def add_docstring_to_source(
    path: Union[str, Path],
    version: int = 4,
    include_auto_gen_txt: bool = True,
    recreate_auto_gen_docs: bool = False,
    model: str = "code-davinci-002",
    temperature: float = 0.2,
    max_tokens: int = 250,
    top_p: float = 1.0,
    n: int = 3,
    prompt: Optional[str] = None,
) -> None:

    path = Path(path)
    files = _get_files(path) if path.is_dir() else [path]

    frequency_penalty = 0.0
    presence_penalty = 0.0
    stop = ["#", '"""']

    for file in files:
        if file.suffix == ".ipynb":
            _add_docstring_to_nb(
                file=file,
                version=version,
                include_auto_gen_txt=include_auto_gen_txt,
                recreate_auto_gen_docs=recreate_auto_gen_docs,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                n=n,
                prompt=prompt,
            )
        else:
            _add_docstring_to_py(
                file=file,
                include_auto_gen_txt=include_auto_gen_txt,
                recreate_auto_gen_docs=recreate_auto_gen_docs,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                n=n,
                prompt=prompt,
            )

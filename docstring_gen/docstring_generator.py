# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Docstring_Generator.ipynb.

# %% auto 0
__all__ = ['AUTO_GEN_TXT', 'PROMPT_TEMPLATE', 'DEFAULT_PROMPT', 'add_docstring_to_source']

# %% ../nbs/Docstring_Generator.ipynb 2
import ast
import tokenize
import os
from typing import *
from pathlib import Path
from io import BytesIO
from configparser import ConfigParser

import nbformat
import openai

from ._helpers.utils import completions_with_backoff

# %% ../nbs/Docstring_Generator.ipynb 4
def _get_code_from_source(source: str, start_line_no: int, end_line_no: int) -> str:
    """Extracts the code from the source file.

        Args:
            source: The source code of the file.
            start_line_no: The line number from which the code is to be extracted.
            end_line_no: The line number till which the code is to be extracted.

        Returns:
            The code extracted from the source file.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    source_lines = source.split("\n")
    extracted_lines = source_lines[start_line_no - 1 : end_line_no]
    return "\n".join(extracted_lines)

# %% ../nbs/Docstring_Generator.ipynb 6
def _calculate_end_lineno(source: str, start_line_no: int) -> int:
    """Calculates the end line number of a block of code.

    Args:
        source: The source code of the file.
        start_line_no: The line number of the start of the block.

    Returns:
        The line number of the end of the block.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    lines = source.split("\n")[start_line_no - 1 :]
    first_indent = len(lines[0]) - len(lines[0].lstrip())
    end_line_in_source = 0

    for i, line in enumerate(lines[1:]):
        if len(line) - len(line.lstrip()) == first_indent and line.strip() != "":
            end_line_in_source = i
            break

    ret_val = (
        len(source.split("\n"))
        if end_line_in_source == 0
        else end_line_in_source + start_line_no
    )
    return ret_val - 1

# %% ../nbs/Docstring_Generator.ipynb 8
def _line_has_decorator(source: str, lineno: int) -> bool:
    """Checks if a line in a source file has a decorator.

    Args:
        source: The source code of the file.
        lineno: The line number to check.

    Returns:
        True if the line has a decorator, False otherwise.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    line = "".join(source.split("\n")[lineno - 1])
    return line.startswith("@") or line.strip() == ""


def _get_start_line_for_class_or_func(source: str, lineno: int) -> int:
    """Returns the line number of the first line of the class or function definition.
        This is useful for getting the line number of the class or function definition
        when the line number of a decorator is given.

        Args:
            source: The source code of the file.
            lineno: The line number of the decorator.

        Returns:
            The line number of the first line of the class or function definition.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    if not _line_has_decorator(source, lineno):
        return lineno

    original_lineno = lineno
    total_lines = source.split("\n")
    for i in total_lines:
        lineno += 1
        if lineno > len(total_lines):
            break
        if not _line_has_decorator(source, lineno):
            return lineno
    return original_lineno

# %% ../nbs/Docstring_Generator.ipynb 11
def _get_lineno_to_append_docstring(source: str, lineno: int) -> int:
    """This function takes a source code string and a line number and returns the line number
        where the docstring should be appended.
        This is done by tokenizing the source code and checking if the tokenization is successful.
        If it is not successful, the line number is incremented and the tokenization is tried again.
        This is done until the tokenization is successful.
        The line number where the tokenization is successful is returned.
        If the tokenization is never successful, a TokenError is raised.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    line_offset = 0
    is_src_tokenized = False
    lines = source.split("\n")[lineno - 1 :]

    for i in range(len(lines)):
        line = "".join(source.split("\n")[lineno - 1 :][: i + 1])
        if line != "":
            try:
                list(tokenize.tokenize(BytesIO(line.encode("utf-8")).readline))
                is_src_tokenized = True
                break
            except tokenize.TokenError as e:
                line_offset += 1
                continue
    if not is_src_tokenized:
        raise tokenize.TokenError(f"TokenError: {source}")

    ret_val = line_offset + lineno
    return ret_val

# %% ../nbs/Docstring_Generator.ipynb 14
AUTO_GEN_TXT = "Note: The above docstring is autogenerated by docstring-gen library!\n"


def _inject_docstring_to_source(
    source: str,
    docstring: str,
    lineno: int,
    node_col_offset: int,
    include_auto_gen_txt: bool,
) -> str:
    """Injects a docstring into a source code string.

    Args:
        source: The source code string.
        docstring: The docstring to inject.
        lineno: The line number to inject the docstring.
        node_col_offset: The column offset of the node.
        include_auto_gen_txt: Whether to include the auto-generated text.

    Returns:
        The source code string with the docstring injected.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    lineno = _get_lineno_to_append_docstring(source, lineno)
    lines = source.split("\n")
    indented_docstring = "\n".join(
        [
            line
            if i == 0 or i == len(docstring.split("\n")) - 1
            else f"{' ' * (node_col_offset + 4)}{line}"
            for i, line in enumerate(docstring.split("\n"))
        ]
    )
    indent = node_col_offset + 4
    nl = "\n"
    auto_gen_txt = (
        f'{nl + nl + (" " * indent + AUTO_GEN_TXT) if include_auto_gen_txt else ""}'
    )
    lines.insert(
        lineno,
        f'{" " * indent}"""{indented_docstring}{auto_gen_txt}{" " * indent}"""',
    )
    return "\n".join(lines)

# %% ../nbs/Docstring_Generator.ipynb 17
PROMPT_TEMPLATE = '''
# Python 3.7

{source}

{prompt}
"""
'''

DEFAULT_PROMPT = (
    "# An elaborate, high quality docstring in Google style for the above function:"
)


def _generate_docstring_using_codex(source: str, **kwargs) -> str:
    """Generate a docstring for a function using the OpenAI API.

    Args:
        source (str): The source code of the function.
        prompt (str): The prompt to use for the docstring.
        engine (str): The engine to use.
        temperature (float): The temperature to use.
        top_p (float): The top_p to use.
        max_tokens (int): The max_tokens to use.
        stop (str): The stop token to use.
        stream (bool): Whether to stream the response.
        logprobs (int): The number of logprobs to return.
        n (int): The number of completions to return.
        frequency_penalty (float): The frequency penalty to use.
        presence_penalty (float): The presence penalty to use.
        best_of (int): The number of best completions to return.
        logprobs (int): The number of logprobs to return.
        stop (str): The stop token to use.
        stream (bool): Whether to stream the response.
    frequency

    Note: The above docstring is autogenerated by docstring-gen library!
    """
    prompt = DEFAULT_PROMPT if kwargs["prompt"] is None else kwargs["prompt"]
    kwargs["prompt"] = PROMPT_TEMPLATE.format(source=source, prompt=prompt)
    try:
        response = completions_with_backoff(**kwargs)

    except openai.error.AuthenticationError as e:
        raise openai.error.AuthenticationError(
            "No API key provided. Please set the API key in the environment variable OPENAI_API_KEY=<API-KEY>. You can generate API keys in the OpenAI web interface. See https://onboard.openai.com for details."
        )

    ret_val: str = response.choices[0].text
    return ret_val

# %% ../nbs/Docstring_Generator.ipynb 20
def _add_docstring(
    source: str,
    node: Union[ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef],
    line_offset: int,
    include_auto_gen_txt: bool,
    **kwargs
) -> Tuple[str, int]:
    """Adds a docstring to the given node in the source code.

        Args:
            source (str): The source code.
            node (Union[ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef]): The node to which the docstring is to be added.
            line_offset (int): The line offset of the source code.
            include_auto_gen_txt (bool): Whether to include the text "Auto-generated by Codex" in the docstring.
            **kwargs: Keyword arguments to be passed to the function _generate_docstring_using_codex.

        Returns:
            Tuple[str, int]: A tuple containing the source code with the docstring added and the line offset.


    Note: The above docstring is autogenerated by docstring-gen library!
    """

    line_no = node.lineno + line_offset

    # Fix for ast's node.lineno giving line number of decorator
    # instead of function/class definition in Python 3.7
    # Delete the below line once support for Python 3.7 is dropped
    line_no = _get_start_line_for_class_or_func(source, line_no)

    if hasattr(node, "end_lineno") and node.end_lineno is not None:
        end_line_no = node.end_lineno + line_offset
    else:
        end_line_no = _calculate_end_lineno(source, line_no)

    code = _get_code_from_source(source, line_no, end_line_no)
    docstring = _generate_docstring_using_codex(code, **kwargs)

    source = _inject_docstring_to_source(
        source, docstring, line_no, node.col_offset, include_auto_gen_txt
    )
    line_offset += (
        len(docstring.split("\n"))
        if not include_auto_gen_txt
        else len(docstring.split("\n")) + 3
    )
    return source, line_offset

# %% ../nbs/Docstring_Generator.ipynb 22
def _check_and_add_docstrings_to_source(
    source: str, include_auto_gen_txt: bool, **kwargs
) -> str:
    """Checks and adds docstrings to the source code.

        Args:
            source (str): The source code to be checked and modified.
            include_auto_gen_txt (bool): Whether to include the auto-generated text in the docstring.
            **kwargs: Additional keyword arguments.

        Returns:
            str: The modified source code.


    Note: The above docstring is autogenerated by docstring-gen library!
    """

    tree = ast.parse(source)
    line_offset = 0

    for node in tree.body:
        if not isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
            continue
        if ast.get_docstring(node) is not None:
            continue

        # A class or a function without docstring
        source, line_offset = _add_docstring(
            source, node, line_offset, include_auto_gen_txt, **kwargs
        )
        if not isinstance(node, ast.ClassDef):
            continue
        # Is a class and we need to check the functions inside
        # 29 - 36 make it as a recursive function
        for f in node.body:
            if not isinstance(f, (ast.FunctionDef, ast.AsyncFunctionDef)):
                continue
            if ast.get_docstring(f) is not None:
                continue

            # should be a function inside the class for which there is no docstring
            source, line_offset = _add_docstring(
                source, f, line_offset, include_auto_gen_txt, **kwargs
            )

    return source

# %% ../nbs/Docstring_Generator.ipynb 24
def _get_files(nb_path: Path) -> List[Path]:
    """Get all Python files and notebooks in a directory.

    Parameters
    ----------
    nb_path : Path
        The path to the directory containing the notebooks.

    Returns
    -------
    List[Path]
        A list of paths to the Python files and notebooks.

    Raises
    ------
    ValueError
        If the directory does not contain any Python files or notebooks.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    exts = [".ipynb", ".py"]
    files = [
        f
        for f in nb_path.rglob("*")
        if f.suffix in exts
        and not any(p.startswith(".") for p in f.parts)
        and not f.name.startswith("_")
    ]

    if len(files) == 0:
        raise ValueError(
            f"The directory {nb_path.resolve()} does not contain any Python files or notebooks"
        )

    return files

# %% ../nbs/Docstring_Generator.ipynb 27
def _add_docstring_to_nb(
    file: Path, version: int, include_auto_gen_txt: bool, **kwargs
):
    """Adds docstrings to all functions in a Jupyter notebook.

    Parameters
    ----------
    file : Path
        The path to the Jupyter notebook.
    version : int
        The version of the Jupyter notebook.
    include_auto_gen_txt : bool
        Whether to include the text "Auto-generated by ..." in the docstring.
    kwargs : dict
        Keyword arguments to be passed to the function
        `_check_and_add_docstrings_to_source`.

    Returns
    -------
    None

    Raises
    ------
    None

    Notes
    -----
    None

    Examples
    --------
    None


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    _f = nbformat.read(file, as_version=version)
    for cell in _f.cells:
        if cell.cell_type == "code":
            cell["source"] = _check_and_add_docstrings_to_source(
                cell["source"], include_auto_gen_txt, **kwargs
            )
    nbformat.write(_f, file)


def _add_docstring_to_py(file: Path, include_auto_gen_txt: bool, **kwargs):
    """Adds docstrings to all functions and classes in a Python file.

    :param file: The file to add docstrings to.
    :param include_auto_gen_txt: Whether to include the "This file was auto-generated" text.
    :param kwargs: Additional keyword arguments to pass to the docstring generator.


    Note: The above docstring is autogenerated by docstring-gen library!
    """
    with file.open("r") as f:
        source = f.read()
    source = _check_and_add_docstrings_to_source(source, include_auto_gen_txt, **kwargs)
    with file.open("w") as f:
        f.write(source)


def add_docstring_to_source(
    path: Union[str, Path],
    version: int = 4,
    include_auto_gen_txt: bool = True,
    model: str = "code-davinci-002",
    temperature: int = 0,
    max_tokens: int = 250,
    top_p: float = 1.0,
    frequency_penalty: float = 0.0,
    presence_penalty: float = 0.0,
    stop: List[str] = ["#", '"""'],
    prompt: Optional[str] = None,
) -> None:
    """Adds a docstring to the source code.

    This function adds a docstring to the source code.

    Args:
        path: The path to the source code.
        version: The version of the docstring.
        include_auto_gen_txt: Whether to include the text "Auto-generated by Code-DaVinci".
        model: The model to use.
        temperature: The temperature to use.
        max_tokens: The maximum number of tokens to use.
        top_p: The top p to use.
        frequency_penalty: The frequency penalty to use.
        presence_penalty: The presence penalty to use.
        stop: The stop tokens to use.
        prompt: The prompt to use.

    Returns:
        None

    Raises:
        ValueError: If the path is not a directory or a Python file.


    Note: The above docstring is autogenerated by docstring-gen library!
    """

    path = Path(path)
    files = _get_files(path) if path.is_dir() else [path]

    for file in files:
        if file.suffix == ".ipynb":
            _add_docstring_to_nb(
                file=file,
                version=version,
                include_auto_gen_txt=include_auto_gen_txt,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                prompt=prompt,
            )
        else:
            _add_docstring_to_py(
                file=file,
                include_auto_gen_txt=include_auto_gen_txt,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                prompt=prompt,
            )

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Docstring_Generator.ipynb.

# %% auto 0
__all__ = ['AUTO_GEN_PERFIX', 'AUTO_GEN_BODY', 'AUTO_GEN_SUFFIX', 'AUTO_GEN_TXT', 'DOCSTRING_RETRY_ATTEMPTS', 'PROMPT_TEMPLATE',
           'DEFAULT_PROMPT', 'add_docstring_to_source']

# %% ../nbs/Docstring_Generator.ipynb 2
import ast
import tokenize
import os
import re
from typing import *
from pathlib import Path
from io import BytesIO
from configparser import ConfigParser

import nbformat
import openai

from ._helpers.utils import completions_with_backoff

# %% ../nbs/Docstring_Generator.ipynb 4
def _get_code_from_source(source: str, start_line_no: int, end_line_no: int) -> str:
    """This function takes in the source code of a python file, the start line number and the end line number
        and returns the code snippet from the source code.

        Args:
            source (str): The source code of the python file
            start_line_no (int): The start line number
            end_line_no (int): The end line number

        Returns:
            str: The code snippet from the source code

        Raises:
            ValueError: If the start line number is greater than the end line number


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    source_lines = source.split("\n")
    extracted_lines = source_lines[start_line_no - 1 : end_line_no]
    return "\n".join(extracted_lines)

# %% ../nbs/Docstring_Generator.ipynb 6
def _calculate_end_lineno(source: str, start_line_no: int) -> int:
    """Calculate the end line number of a function.

    Args:
        source: The source code of the file.
        start_line_no: The line number of the function definition.

    Returns:
        The line number of the end of the function.

    Raises:
        ValueError: If the function definition is not found.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    lines = source.split("\n")[start_line_no - 1 :]
    first_indent = len(lines[0]) - len(lines[0].lstrip())
    end_line_in_source = 0

    for i, line in enumerate(lines[1:]):
        if len(line) - len(line.lstrip()) == first_indent and line.strip() != "":
            end_line_in_source = i
            break

    ret_val = (
        len(source.split("\n"))
        if end_line_in_source == 0
        else end_line_in_source + start_line_no
    )
    return ret_val - 1

# %% ../nbs/Docstring_Generator.ipynb 8
def _line_has_decorator(source: str, lineno: int) -> bool:
    """This function checks if a line has a decorator.
        Args:
            source: The source code of the file
            lineno: The line number of the line to be checked
        Returns:
            True if the line has a decorator, False otherwise
        Raises:
            None


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    line = "".join(source.split("\n")[lineno - 1])
    return line.startswith("@") or line.strip() == ""


def _get_start_line_for_class_or_func(source: str, lineno: int) -> int:
    """


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    if not _line_has_decorator(source, lineno):
        return lineno

    original_lineno = lineno
    total_lines = source.split("\n")
    for i in total_lines:
        lineno += 1
        if lineno > len(total_lines):
            break
        if not _line_has_decorator(source, lineno):
            return lineno
    return original_lineno

# %% ../nbs/Docstring_Generator.ipynb 11
def _get_lineno_to_append_docstring(source: str, lineno: int) -> int:
    """This function takes in a source code and a line number and returns the line number where the docstring should be appended.
        It does this by checking if the source code is tokenized. If it is not, it raises a token error.
        If it is, it returns the line number where the docstring should be appended.

        Args:
            source: The source code of the function
            lineno: The line number of the function

        Returns:
            The line number where the docstring should be appended

        Raises:
            TokenError: If the source code is not tokenized


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    line_offset = 0
    is_src_tokenized = False
    lines = source.split("\n")[lineno - 1 :]

    for i in range(len(lines)):
        line = "".join(source.split("\n")[lineno - 1 :][: i + 1])
        if line != "":
            try:
                list(tokenize.tokenize(BytesIO(line.encode("utf-8")).readline))
                is_src_tokenized = True
                break
            except tokenize.TokenError as e:
                line_offset += 1
                continue
    if not is_src_tokenized:
        raise tokenize.TokenError(f"TokenError: {source}")

    ret_val = line_offset + lineno
    return ret_val

# %% ../nbs/Docstring_Generator.ipynb 14
AUTO_GEN_PERFIX = """!!! note

"""

# AUTO_GEN_BODY will be used in the {} function for replacing the autogenerated docstring from the previous run
AUTO_GEN_BODY = "The above docstring is autogenerated by docstring-gen library"

AUTO_GEN_SUFFIX = "(https://github.com/airtai/docstring-gen)"

AUTO_GEN_TXT = AUTO_GEN_PERFIX + " " * 4 + AUTO_GEN_BODY + " " + AUTO_GEN_SUFFIX

# %% ../nbs/Docstring_Generator.ipynb 16
def _inject_docstring_to_source(
    source: str,
    docstring: str,
    lineno: int,
    node_col_offset: int,
    include_auto_gen_txt: bool,
) -> str:
    """Injects a docstring into a source file.

    Args:
        source: The source code to inject the docstring into.
        docstring: The docstring to inject.
        lineno: The line number to inject the docstring at.
        node_col_offset: The column offset of the node to inject the docstring at.
        include_auto_gen_txt: Whether to include the auto-generated text.

    Returns:
        The source code with the docstring injected.

    Raises:
        ValueError: If the source code is invalid.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    lineno = _get_lineno_to_append_docstring(source, lineno)
    lines = source.split("\n")
    indented_docstring = "\n".join(
        [
            line
            if i == 0 or i == len(docstring.split("\n")) - 1
            else f"{' ' * (node_col_offset + 4)}{line}"
            for i, line in enumerate(docstring.split("\n"))
        ]
    )
    indent = node_col_offset + 4
    nl = "\n"
    auto_gen_txt = f'{nl + nl + (nl.join((" " * indent + i) for i in AUTO_GEN_TXT.split(nl))) + nl if include_auto_gen_txt else ""}'
    lines.insert(
        lineno,
        f'{" " * indent}"""{indented_docstring}{auto_gen_txt}{" " * indent}"""',
    )
    return "\n".join(lines)

# %% ../nbs/Docstring_Generator.ipynb 20
DOCSTRING_RETRY_ATTEMPTS = 1

PROMPT_TEMPLATE = '''
# Python 3.7

{source}

{prompt}
"""
'''

# Having multi-line prompts works the best with the codex model
# Note: The prompt must start with the # symbol
DEFAULT_PROMPT = """
# An elaborate, high quality docstring for the above function adhering to the Google python docstring format:
# Any deviation from the Google python docstring format will not be accepted
# Include one line description, args, returns and raises
"""


def _get_response(**kwargs):
    """This function takes in a prompt and returns a response.
        Args:
            prompt: A string that is the prompt for the response.
            max_tokens: An integer that is the maximum number of tokens to be returned.
            temperature: A float that is the temperature for the response.
            top_p: A float that is the top_p for the response.
            n: An integer that is the number of responses to be returned.
            stream: A string that is the stream for the response.
            logprobs: A float that is the logprobs for the response.
            stop: A string that is the stop for the response.
        Returns:
            A string that is the response.
        Raises:
            openai.error.AuthenticationError: If no API key is provided.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    try:
        response = completions_with_backoff(**kwargs)
    except openai.error.AuthenticationError as e:
        raise openai.error.AuthenticationError(
            "No API key provided. Please set the API key in the environment variable OPENAI_API_KEY=<API-KEY>. You can generate API keys in the OpenAI web interface. See https://onboard.openai.com for details."
        )
    return response.choices[0].text


def _generate_docstring_using_codex(source: str, **kwargs) -> str:
    """Generates a docstring for a given source code using codex.

    Args:
        source (str): The source code for which the docstring is to be generated.
        **kwargs: Arbitrary keyword arguments.

    Returns:
        str: The generated docstring.

    Raises:
        ValueError: If the source code is not a string.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    prompt = DEFAULT_PROMPT if kwargs["prompt"] is None else kwargs["prompt"]
    prompt = "# " + prompt if not prompt.startswith("#") else prompt
    kwargs["prompt"] = PROMPT_TEMPLATE.format(source=source, prompt=prompt)

    ret_val: str = _get_response(**kwargs)
    for i in range(DOCSTRING_RETRY_ATTEMPTS):
        if "Args:" in ret_val:
            break
        ret_val = _get_response(**kwargs)

    return ret_val

# %% ../nbs/Docstring_Generator.ipynb 23
def _add_docstring(
    source: str,
    node: Union[ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef],
    line_offset: int,
    include_auto_gen_txt: bool,
    **kwargs,
) -> Tuple[str, int]:
    """Adds a docstring to a class or function.

    Args:
        source: The source code of the file.
        node: The class or function node.
        line_offset: The line offset of the file.
        include_auto_gen_txt: Whether to include the auto generated text.
        **kwargs: Additional keyword arguments.

    Returns:
        A tuple of the source code and the line offset.

    Raises:
        ValueError: If the source code is not a string.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    line_no = node.lineno + line_offset

    # Fix for  Python 3.7
    # Delete the below line once support for Python 3.7 is dropped
    line_no = _get_start_line_for_class_or_func(source, line_no)

    if hasattr(node, "end_lineno") and node.end_lineno is not None:
        end_line_no = node.end_lineno + line_offset
    else:
        end_line_no = _calculate_end_lineno(source, line_no)

    code = _get_code_from_source(source, line_no, end_line_no)
    docstring = _generate_docstring_using_codex(code, **kwargs)

    source = _inject_docstring_to_source(
        source, docstring, line_no, node.col_offset, include_auto_gen_txt
    )
    line_offset += (
        len(docstring.split("\n"))
        if not include_auto_gen_txt
        else len(docstring.split("\n"))
        + len(AUTO_GEN_TXT.split("\n"))
        + 2  # the 2 is for the \n characters at the beginning
    )
    return source, line_offset

# %% ../nbs/Docstring_Generator.ipynb 25
def _remove_auto_generated_docstring(source: str) -> str:
    """Removes the auto-generated docstring from the source code.

    Args:
        source (str): The source code.

    Returns:
        str: The source code with the auto-generated docstring removed.

    Raises:
        ValueError: If the source code does not contain the auto-generated docstring.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    return re.sub(
        f'"""((?!""").)*?({AUTO_GEN_BODY}).*?"""', "", source, flags=re.DOTALL
    )

# %% ../nbs/Docstring_Generator.ipynb 27
def _check_and_add_docstrings_to_source(
    source: str, include_auto_gen_txt: bool, **kwargs
) -> str:
    """This function checks if the source code has docstrings for all the functions and classes.
        If not, it adds the docstrings to the source code.
        It also removes the auto-generated docstrings.

        Args:
            source (str): The source code of the file.
            include_auto_gen_txt (bool): Whether to include the auto-generated text in the docstring.
            **kwargs: Any other keyword arguments.

        Returns:
            str: The source code with the docstrings added.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    source = _remove_auto_generated_docstring(source)
    tree = ast.parse(source)
    line_offset = 0

    for node in tree.body:
        if not isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
            continue

        if ast.get_docstring(node) is not None:
            continue

        source, line_offset = _add_docstring(
            source, node, line_offset, include_auto_gen_txt, **kwargs
        )
        if not isinstance(node, ast.ClassDef):
            continue
        # Is a class and we need to check the functions inside
        # 29 - 36 make it as a recursive function
        for f in node.body:
            if not isinstance(f, (ast.FunctionDef, ast.AsyncFunctionDef)):
                continue

            if ast.get_docstring(f) is not None:
                continue

            # should be a function inside the class for which there is no docstring
            source, line_offset = _add_docstring(
                source, f, line_offset, include_auto_gen_txt, **kwargs
            )

    return source

# %% ../nbs/Docstring_Generator.ipynb 29
def _get_files(nb_path: Path) -> List[Path]:
    """This function returns a list of files in the given directory.
        The files returned are either .ipynb or .py files.
        The files returned do not start with a '.' or '_'

        Args:
            nb_path: The path to the directory to be searched

        Returns:
            A list of files in the given directory

        Raises:
            ValueError: If the directory does not contain any Python files or notebooks


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    exts = [".ipynb", ".py"]
    files = [
        f
        for f in nb_path.rglob("*")
        if f.suffix in exts
        and not any(p.startswith(".") for p in f.parts)
        and not f.name.startswith("_")
    ]

    if len(files) == 0:
        raise ValueError(
            f"The directory {nb_path.resolve()} does not contain any Python files or notebooks"
        )

    return files

# %% ../nbs/Docstring_Generator.ipynb 32
def _add_docstring_to_nb(
    file: Path, version: int, include_auto_gen_txt: bool, **kwargs
):
    """Adds docstrings to all functions in a notebook.
        Args:
            file: Path to the notebook file.
            version: Version of the notebook file.
            include_auto_gen_txt: Whether to include the text "Auto-generated by nb_docstrings" in the docstring.
            kwargs: Additional keyword arguments to be passed to the function _check_and_add_docstrings_to_source.
        Returns:
            None
        Raises:
            None


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    _f = nbformat.read(file, as_version=version)
    for cell in _f.cells:
        if cell.cell_type == "code":
            cell["source"] = _check_and_add_docstrings_to_source(
                cell["source"], include_auto_gen_txt, **kwargs
            )
    nbformat.write(_f, file)


def _add_docstring_to_py(file: Path, include_auto_gen_txt: bool, **kwargs):
    """Adds docstrings to all functions in a python file.
        Args:
            file: Path to the python file
            include_auto_gen_txt: If True, include the text "This function was auto-generated from the original Numba source code.
            **kwargs: Additional keyword arguments to pass to the docstring parser
        Returns:
            None
        Raises:
            ValueError: If the file is not a python file


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    with file.open("r") as f:
        source = f.read()
    source = _check_and_add_docstrings_to_source(source, include_auto_gen_txt, **kwargs)
    with file.open("w") as f:
        f.write(source)


def add_docstring_to_source(
    path: Union[str, Path],
    version: int = 4,
    include_auto_gen_txt: bool = True,
    model: str = "code-davinci-002",
    temperature: int = 0,
    max_tokens: int = 250,
    top_p: float = 1.0,
    frequency_penalty: float = 0.0,
    presence_penalty: float = 0.0,
    stop: List[str] = ["#", '"""'],
    prompt: Optional[str] = None,
) -> None:
    """Adds a docstring to the source code.

    Args:
        path: The path to the source code file or directory.
        version: The version of the docstring format to use.
        include_auto_gen_txt: Whether to include the text "Auto-generated by Code-Davinci" in the docstring.
        model: The model to use for generating the docstring.
        temperature: The temperature to use for generating the docstring.
        max_tokens: The maximum number of tokens to use for generating the docstring.
        top_p: The top_p to use for generating the docstring.
        frequency_penalty: The frequency_penalty to use for generating the docstring.
        presence_penalty: The presence_penalty to use for generating the docstring.
        stop: The stop tokens to use for generating the docstring.
        prompt: The prompt to use for generating the docstring.

    Raises:
        ValueError: If the path is not a file or directory.


    !!! note

        The above docstring is autogenerated by docstring-gen library (https://github.com/airtai/docstring-gen)
    """

    path = Path(path)
    files = _get_files(path) if path.is_dir() else [path]

    for file in files:
        if file.suffix == ".ipynb":
            _add_docstring_to_nb(
                file=file,
                version=version,
                include_auto_gen_txt=include_auto_gen_txt,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                prompt=prompt,
            )
        else:
            _add_docstring_to_py(
                file=file,
                include_auto_gen_txt=include_auto_gen_txt,
                model=model,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=top_p,
                frequency_penalty=frequency_penalty,
                presence_penalty=presence_penalty,
                stop=stop,
                prompt=prompt,
            )
